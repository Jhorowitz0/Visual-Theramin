// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


RWStructuredBuffer<float3> Colors;
RWStructuredBuffer<float3> NewColors;
float PalleteSize;

RWTexture2D<float3> Input;
RWTexture2D<float3> Output;
float ResolutionX;
float ResolutionY;

float rand(float2 co){
    return(frac(sin(dot(co.xy, float2(12.9898,78.233))) * 43758.5453))*1;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float x = id.x/ResolutionX;
    float y = id.y/ResolutionY;

    float3 closestColor = float3(0,0,0);
    float closestDist = 1000;
    int closestColorIndex=0;
    for(int i = 0; i < PalleteSize; i++){
        float3 c1 = Colors[i];
        float3 c2 = Input[id.xy];

        float rd = pow(c2[0]-c1[0],2);
        float gd = pow(c2[1]-c1[1],2);
        float bd = pow(c2[2]-c1[2],2);

        float dist = sqrt(rd+gd+bd);
        if(dist < closestDist){
            closestDist = dist;
            closestColor = c1;
            closestColorIndex = i;
        }
    }

    float rOffset = Input[id.xy].x - closestColor.x;
    float gOffset = Input[id.xy].y - closestColor.y;
    float bOffset = Input[id.xy].z - closestColor.z;

    float3 color = NewColors[closestColorIndex];

    color.x += rOffset;
    color.y += gOffset;
    color.z += bOffset;

    // color[0] = color[0] + rOffset;
    // color[1] = color[1] + gOffset;
    // color[2] = color[2] + bOffset;

    Output[id.xy] = color;
    // Input[id.xy] = float3(closestColorIndex/PalleteSize,closestColorIndex/PalleteSize,closestColorIndex/PalleteSize);
}
